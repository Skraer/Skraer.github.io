{"version":3,"names":[],"mappings":"","sources":["main.js"],"sourcesContent":["const slider = new Swiper('.tools__slider',{\r\n    spaceBetween: 0,\r\n    autoHeight: true,\r\n    // initialSlide: 5,\r\n    breakpoints: {\r\n        320: {\r\n            slidesPerView: 1,\r\n        },\r\n        768: {\r\n            slidesPerView: 2,\r\n        },\r\n        992: {\r\n            slidesPerView: 3,\r\n        }\r\n    }\r\n});\r\n\r\nfunction getFonts() {\r\n    return [\r\n        ['Arial', 'sans-serif'],\r\n        ['Comic Sans MS', 'cursive'],\r\n        ['Courier New', 'monospace'],\r\n        ['Georgia', 'serif'],\r\n        ['Lucida Console', 'monospace'],\r\n        ['Lucida Sans Unicode', 'sans-serif'],\r\n        ['Palatino Linotype', 'serif'],\r\n        ['Tahoma', 'sans-serif'],\r\n        ['Times New Roman', 'serif'],\r\n        ['Trebuchet MS', 'sans-serif'],\r\n        ['Verdana', 'sans-serif']\r\n    ];\r\n}\r\n\r\nclass Editor {\r\n    constructor (ops) {\r\n        this.canvas = ops.canvas;\r\n        this.ctx = ops.context;\r\n        this.width = document.documentElement.clientWidth;\r\n        this.refreshWidth();\r\n        this.height = +this.canvas.height;\r\n    }\r\n    refreshWidth() {this.canvas.width = this.width}\r\n    getTextCanvasPosition(textElem) {\r\n        const w = this.width,\r\n            h = this.height,\r\n            t = textElem,\r\n            pos = textElem.pos;\r\n        const params = {};\r\n        switch (pos[0]) {\r\n            case 't':\r\n                params.baseline = 'top';\r\n                params.y = 0 + t.strokeWidth;\r\n                break;\r\n            case 'c':\r\n                params.baseline = 'middle';\r\n                params.y = Math.floor(h / 2);\r\n                break;\r\n            case 'b':\r\n                params.baseline = 'bottom';\r\n                params.y = h - t.strokeWidth;\r\n                break;\r\n        }\r\n        switch (pos[1]) {\r\n            case 'l':\r\n                params.textAlign = 'left';\r\n                params.x = 0 + t.strokeWidth;\r\n                break;\r\n            case 'c':\r\n                params.textAlign = 'center';\r\n                params.x = Math.floor(w / 2);\r\n                break;\r\n            case 'r':\r\n                params.textAlign = 'right';\r\n                params.x = w - t.strokeWidth;\r\n                break;\r\n        }\r\n        return params;\r\n    }\r\n    setFontAndAlign(textElem) {\r\n        const t = textElem;\r\n        const ctx = this.ctx;\r\n        const coords = this.getTextCanvasPosition(t);\r\n\r\n        ctx.font = `${t.weight} ${t.size}px sans-serif`;    //TODO add selection of font\r\n        ctx.textBaseline = coords.baseline;\r\n        ctx.textAlign = coords.textAlign;\r\n    }\r\n    setFilling(textElem) {\r\n        const t = textElem;\r\n        const ctx = this.ctx;\r\n        const coords = this.getTextCanvasPosition(t);\r\n        let metrics = ctx.measureText(t.content);\r\n        function getStartPoint() {\r\n            if (t.gradientDirection === 'hor') {\r\n                switch (coords.textAlign) {\r\n                    case 'left':\r\n                        return Math.floor(coords.x);\r\n                    case 'center':\r\n                        return Math.floor(coords.x - metrics.width / 2);\r\n                    case 'right':\r\n                        return Math.floor(coords.x - metrics.width);\r\n                }\r\n            } else if (t.gradientDirection === 'ver') {\r\n                switch (coords.baseline) {\r\n                    case 'top':\r\n                        return Math.floor(coords.y);\r\n                    case 'middle':\r\n                        return Math.floor(coords.y - t.size / 2);\r\n                    case 'bottom':\r\n                        return Math.floor(coords.y - t.size);\r\n                }\r\n            }\r\n        }\r\n        function getCenterPoint() {\r\n            if (t.gradientDirection === 'hor') {\r\n                switch (coords.baseline) {\r\n                    case 'top':\r\n                        return Math.floor(coords.y + t.size / 2);\r\n                    case 'middle':\r\n                        return Math.floor(coords.y);\r\n                    case 'bottom':\r\n                        return Math.floor(coords.y - t.size / 2);\r\n                }\r\n            } else if (t.gradientDirection === 'ver') {\r\n                switch (coords.textAlign) {\r\n                    case 'left':\r\n                        return Math.floor(coords.y + metrics.width / 2);\r\n                    case 'center':\r\n                        return Math.floor(coords.y);\r\n                    case 'right':\r\n                        return Math.floor(coords.y - metrics.width / 2);\r\n                }\r\n            }\r\n        }\r\n        function getEndPoint() {\r\n            if (t.gradientDirection === 'hor') {\r\n                switch (coords.textAlign) {\r\n                    case 'left':\r\n                        return Math.ceil(coords.x + metrics.width);\r\n                    case 'center':\r\n                        return Math.ceil(coords.x + metrics.width / 2);\r\n                    case 'right':\r\n                        return Math.ceil(coords.x);\r\n                }\r\n            } else if (t.gradientDirection === 'ver') {\r\n                switch (coords.baseline) {\r\n                    case 'top':\r\n                        return Math.floor(coords.y + t.size);\r\n                    case 'middle':\r\n                        return Math.floor(coords.y + t.size / 2);\r\n                    case 'bottom':\r\n                        return Math.floor(coords.y);\r\n                }\r\n            }\r\n        }\r\n        let textFilling;\r\n\r\n        if (t.fillingType === 'color') {\r\n            textFilling = t.color;\r\n        } else if (t.fillingType === 'gradient') {\r\n            let start = getStartPoint(),\r\n                center = getCenterPoint(),\r\n                end = getEndPoint();\r\n                if (t.gradientDirection === 'hor') {\r\n                    textFilling = ctx.createLinearGradient(start, center, end, center);\r\n                } else if (t.gradientDirection === 'ver') {\r\n                    textFilling = ctx.createLinearGradient(center, start, center, end);\r\n                }\r\n                textFilling.addColorStop(0, t.gradientStartColor);\r\n                textFilling.addColorStop(1, t.gradientEndColor);\r\n        }\r\n        ctx.fillStyle = textFilling;\r\n        // return textFilling;\r\n    }\r\n    renderText(textElem) {\r\n        const t = textElem;\r\n        const ctx = this.ctx;\r\n        const coords = this.getTextCanvasPosition(t);\r\n\r\n        ctx.clearRect(0, 0, this.width, this.height);\r\n        ctx.beginPath();\r\n\r\n        this.setFontAndAlign(textElem);\r\n        this.setFilling(textElem);\r\n\r\n        ctx.fillText(t.content, coords.x, coords.y);\r\n\r\n        if (t.strokeWidth > 0) {\r\n            ctx.strokeStyle = t.strokeColor;\r\n            ctx.lineWidth = t.strokeWidth;\r\n            ctx.strokeText(t.content, coords.x, coords.y);\r\n        }\r\n        ctx.closePath();\r\n    }\r\n}\r\nclass Tools {\r\n    constructor (ops) {\r\n        this.textInput = ops.textInput;\r\n        this.alignBtns = ops.alignBtns;\r\n        this.fontFamilyBtn = ops.fontFamilyBtn;\r\n        this.textColorBtn = ops.textColorBtn;\r\n        this.strokeWidthBtn = ops.strokeWidthBtn;\r\n        this.strokeColorBtn = ops.strokeColorBtn;\r\n        this.fontSizeBtn = ops.fontSizeBtn;\r\n        /* update */\r\n        this.colorSelectionBtns = ops.colorSelectionBtns;\r\n        this.changeFillingTypePanel();\r\n        this.gradientStartColorBtn = ops.gradientStartColorBtn;\r\n        this.gradientEndColorBtn = ops.gradientEndColorBtn;\r\n        this.gradientDirectionBtns = ops.gradientDirectionBtns;\r\n        this.saveBtn = ops.saveBtn;\r\n        this.shadowActivateBtn = ops.shadowActivateBtn;\r\n        /* ====== */\r\n\r\n        this.textInstance = ops.textInstance;\r\n        this.afterUpdate = ops.afterUpdate;\r\n        this.setup();\r\n    }\r\n    getCheckedRadio(radio) {\r\n        for (let i = 0; i < radio.length; i++) {\r\n            if (radio[i].checked) {\r\n                return radio[i].value;\r\n            }\r\n        }\r\n    }\r\n    setOptions() {\r\n        const t = this.textInstance;\r\n        t.content = this.textInput.value;\r\n        t.size = +this.fontSizeBtn.value;\r\n        t.fontFamily = this.fontFamilyBtn.value;\r\n        t.color = this.textColorBtn.value;\r\n        t.strokeWidth = +this.strokeWidthBtn.value;\r\n        t.strokeColor = this.strokeColorBtn.value;\r\n        t.pos = this.getCheckedRadio(this.alignBtns);\r\n        /* update */\r\n        t.fillingType = this.getCheckedRadio(this.colorSelectionBtns);\r\n        t.gradientStartColor = this.gradientStartColorBtn.value;\r\n        t.gradientEndColor = this.gradientEndColorBtn.value;\r\n        t.gradientDirection = this.getCheckedRadio(this.gradientDirectionBtns);\r\n\r\n        /* ====== */\r\n        this.afterUpdate();\r\n    }\r\n    changeFillingTypePanel() {\r\n        const colorPanel = document.querySelector('#colorPanel');\r\n        const gradientPanel = document.querySelector('#gradientPanel');\r\n        const labelColor = document.querySelector('label[for=\"selectColor\"]');\r\n        const labelGradient = document.querySelector('label[for=\"selectGradient\"]');\r\n        if (this.getCheckedRadio(this.colorSelectionBtns) === 'color') {\r\n            gradientPanel.classList.add('hidden');\r\n            colorPanel.classList.remove('hidden');\r\n            labelColor.classList.remove('disabled');\r\n            labelGradient.classList.add('disabled');\r\n        } else if (this.getCheckedRadio(this.colorSelectionBtns) === 'gradient') {\r\n            gradientPanel.classList.remove('hidden');\r\n            colorPanel.classList.add('hidden');\r\n            labelColor.classList.add('disabled');\r\n            labelGradient.classList.remove('disabled');\r\n        }\r\n        slider.slideToClosest();\r\n    }\r\n    changeShadowPanelState() {\r\n        const shadowPanel = document.querySelector('#shadowPanel');\r\n\r\n        if (this.shadowActivateBtn.checked) {\r\n            shadowPanel.classList.remove('disabled');\r\n            // console.log('shadow activated');\r\n        } else {\r\n            // console.log('shadow disabled');\r\n            shadowPanel.classList.add('disabled');\r\n        }\r\n    }\r\n    saveImage() {\r\n        let dataURL = editor.canvas.toDataURL(\"image/png\");\r\n        this.saveBtn.setAttribute('href', dataURL);\r\n        this.saveBtn.setAttribute('download', 'text.png');\r\n    }\r\n    setup() {\r\n        const setOptions = this.setOptions.bind(this);\r\n        const changeFillingTypePanel = this.changeFillingTypePanel.bind(this);\r\n        const changeShadowPanelState = this.changeShadowPanelState.bind(this);\r\n\r\n        const saveImage = this.saveImage.bind(this);\r\n\r\n        this.textInput.oninput = setOptions;\r\n        this.alignBtns.forEach(el => {\r\n            el.onchange = setOptions;\r\n        });\r\n        this.fontFamilyBtn.onchange = setOptions;\r\n        this.textColorBtn.oninput = setOptions;\r\n        this.strokeWidthBtn.oninput = setOptions;\r\n        this.strokeColorBtn.oninput = setOptions;\r\n        this.fontSizeBtn.oninput = setOptions;\r\n        /* update */\r\n        this.colorSelectionBtns.forEach(el => {\r\n            el.onchange = function() {\r\n                changeFillingTypePanel();\r\n                setOptions();\r\n            };\r\n        });\r\n        this.gradientDirectionBtns.forEach(el => {\r\n            el.onchange = setOptions;\r\n        });\r\n        this.gradientStartColorBtn.oninput = setOptions;\r\n        this.gradientEndColorBtn.oninput = setOptions;\r\n        this.shadowActivateBtn.onchange = changeShadowPanelState;\r\n\r\n        this.saveBtn.onclick = saveImage;\r\n        /* ====== */\r\n    }\r\n}\r\n\r\nclass Text {\r\n    constructor(ops) {\r\n        this.content = ops.content || 'Новый текст';\r\n        this.size = ops.size || 16;\r\n        this.fontFamily = ops.fontFamily || this.loadFonts();\r\n        this.color = ops.color || '#000000';\r\n        this.strokeWidth = ops.strokeWidth || 0;\r\n        this.strokeColor = ops.strokeColor || '#000000';\r\n        this.pos = ops.pos || 'cc';\r\n        this.weight = 400;\r\n        this.fillingType = ops.fillingType || 'color';\r\n        this.gradientStartColor = ops.gradientStartColor || '#000000';\r\n        this.gradientEndColor = ops.gradientEndColor || '#000000';\r\n        this.gradientDirection = ops.gradientDirection || 'hor';\r\n    }\r\n    loadFonts() {\r\n        let fontsArr = getFonts();\r\n        fontsArr = fontsArr.map(el => {\r\n            return el[0] + ', ' + el[1];\r\n        });\r\n    }\r\n}\r\nclass Modal {\r\n    constructor (ops) {\r\n        this.elem = ops.elem;\r\n        this.activateBtn = ops.activateBtn;\r\n        this.input = ops.input;\r\n        this.submitBtn = ops.submitBtn;\r\n        this.cancelBtn = ops.cancelBtn;\r\n        this.submitHandler = ops.submitHandler;\r\n        this.cancelHandler = ops.cancelHandler;\r\n        this.text = this.input.value;\r\n\r\n        this.setup();\r\n    }\r\n    show() {\r\n        this.elem.classList.remove('hidden');\r\n        this.elem.classList.add('visible');\r\n        document.body.classList.add('lock');\r\n    }\r\n    hide() {\r\n        this.elem.classList.remove('visible');\r\n        this.elem.classList.add('hidden');\r\n        document.body.classList.remove('lock');\r\n    }\r\n    submit() {\r\n        this.submitHandler();\r\n        this.hide();\r\n    }\r\n    cancel() {\r\n        this.cancelHandler();\r\n        this.hide();\r\n    }\r\n    setup() {\r\n        let modal = this;\r\n        this.activateBtn.addEventListener('click', function() {\r\n            modal.show();\r\n        });\r\n        this.submitBtn.addEventListener('click', function() {\r\n            modal.submit();\r\n        });\r\n        this.cancelBtn.addEventListener('click', function() {\r\n            modal.cancel();\r\n        });\r\n    }\r\n}\r\n\r\nconst editor = new Editor({\r\n    canvas: document.querySelector('#canvas'),\r\n    context: canvas.getContext('2d')\r\n});\r\nconst text = new Text({});\r\nconst tools = new Tools({\r\n    textInput: document.querySelector('#textInput'),\r\n    alignBtns: document.querySelectorAll('input[name=\"align\"]'),\r\n    colorSelectionBtns: document.querySelectorAll('input[name=\"filling-type\"]'),\r\n    fontFamilyBtn: document.querySelector('#paramFontFamily'),\r\n    textColorBtn: document.querySelector('#paramColor'),\r\n    strokeWidthBtn: document.querySelector('#paramStrokeWidth'),\r\n    strokeColorBtn: document.querySelector('#paramStrokeColor'),\r\n    fontSizeBtn: document.querySelector('#paramFontSize'),\r\n    gradientStartColorBtn: document.querySelector('#paramGradientStartColor'),\r\n    gradientEndColorBtn: document.querySelector('#paramGradientEndColor'),\r\n    gradientDirectionBtns: document.querySelectorAll('input[name=\"gradient-direction\"]'),\r\n    shadowActivateBtn: document.querySelector('#shadowActivate'),\r\n    saveBtn: document.querySelector('#saveBtn'),\r\n    textInstance: text,\r\n    afterUpdate: function() {\r\n        editor.renderText(text);\r\n    },\r\n});\r\n"],"file":"../main.js"}